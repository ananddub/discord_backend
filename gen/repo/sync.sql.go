// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUpdatedChannels = `-- name: CountUpdatedChannels :one
SELECT COUNT(*) as total
FROM channels c
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND c.updated_at > $2
`

type CountUpdatedChannelsParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// Count channels updated after timestamp
func (q *Queries) CountUpdatedChannels(ctx context.Context, arg CountUpdatedChannelsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUpdatedChannels, arg.UserID, arg.UpdatedAt)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUpdatedFriends = `-- name: CountUpdatedFriends :one
SELECT COUNT(*) as total
FROM friends
WHERE
    user_id = $1
    AND updated_at > $2
`

type CountUpdatedFriendsParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// Count friends updated after timestamp
func (q *Queries) CountUpdatedFriends(ctx context.Context, arg CountUpdatedFriendsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUpdatedFriends, arg.UserID, arg.UpdatedAt)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUpdatedMessages = `-- name: CountUpdatedMessages :one
SELECT COUNT(*) as total
FROM
    messages m
    INNER JOIN channels c ON m.channel_id = c.id
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND m.updated_at > $2
`

type CountUpdatedMessagesParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// Count messages updated after timestamp
func (q *Queries) CountUpdatedMessages(ctx context.Context, arg CountUpdatedMessagesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUpdatedMessages, arg.UserID, arg.UpdatedAt)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUpdatedServers = `-- name: CountUpdatedServers :one
SELECT COUNT(*) as total
FROM servers s
    INNER JOIN server_members sm ON s.id = sm.server_id
WHERE
    sm.user_id = $1
    AND s.updated_at > $2
`

type CountUpdatedServersParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// Count servers updated after timestamp
func (q *Queries) CountUpdatedServers(ctx context.Context, arg CountUpdatedServersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUpdatedServers, arg.UserID, arg.UpdatedAt)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getServerTimestamp = `-- name: GetServerTimestamp :one
SELECT EXTRACT( EPOCH FROM NOW() ) * 1000 as server_timestamp
`

// Get current server timestamp for sync
func (q *Queries) GetServerTimestamp(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getServerTimestamp)
	var server_timestamp int32
	err := row.Scan(&server_timestamp)
	return server_timestamp, err
}

const getUserLastUpdate = `-- name: GetUserLastUpdate :one
SELECT updated_at FROM users WHERE id = $1
`

// Get user's last profile update timestamp
func (q *Queries) GetUserLastUpdate(ctx context.Context, id int32) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getUserLastUpdate, id)
	var updated_at pgtype.Timestamp
	err := row.Scan(&updated_at)
	return updated_at, err
}

const syncBans = `-- name: SyncBans :many
SELECT b.id, b.server_id, b.user_id, b.moderator_id, b.reason, b.expires_at, b.created_at
FROM bans b
    INNER JOIN server_members sm ON b.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND b.created_at > $2
ORDER BY b.created_at DESC
`

type SyncBansParams struct {
	UserID    int32            `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type SyncBansRow struct {
	ID          int32            `json:"id"`
	ServerID    int32            `json:"server_id"`
	UserID      int32            `json:"user_id"`
	ModeratorID int32            `json:"moderator_id"`
	Reason      pgtype.Text      `json:"reason"`
	ExpiresAt   pgtype.Timestamp `json:"expires_at"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

// Get server bans updated after last_updated_at
func (q *Queries) SyncBans(ctx context.Context, arg SyncBansParams) ([]SyncBansRow, error) {
	rows, err := q.db.Query(ctx, syncBans, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncBansRow
	for rows.Next() {
		var i SyncBansRow
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.UserID,
			&i.ModeratorID,
			&i.Reason,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncChannels = `-- name: SyncChannels :many
SELECT c.id, c.server_id, c.category_id, c.name, c.type, c.position, c.topic, c.is_nsfw, c.slowmode_delay, c.user_limit, c.bitrate, c.is_private, c.created_at, c.updated_at
FROM channels c
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND c.updated_at > $2
ORDER BY c.server_id, c.position
`

type SyncChannelsParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type SyncChannelsRow struct {
	ID            int32            `json:"id"`
	ServerID      int32            `json:"server_id"`
	CategoryID    pgtype.Int4      `json:"category_id"`
	Name          string           `json:"name"`
	Type          string           `json:"type"`
	Position      pgtype.Int4      `json:"position"`
	Topic         pgtype.Text      `json:"topic"`
	IsNsfw        pgtype.Bool      `json:"is_nsfw"`
	SlowmodeDelay pgtype.Int4      `json:"slowmode_delay"`
	UserLimit     pgtype.Int4      `json:"user_limit"`
	Bitrate       pgtype.Int4      `json:"bitrate"`
	IsPrivate     pgtype.Bool      `json:"is_private"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

// Get channels from user's servers, updated after last_updated_at
func (q *Queries) SyncChannels(ctx context.Context, arg SyncChannelsParams) ([]SyncChannelsRow, error) {
	rows, err := q.db.Query(ctx, syncChannels, arg.UserID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncChannelsRow
	for rows.Next() {
		var i SyncChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.CategoryID,
			&i.Name,
			&i.Type,
			&i.Position,
			&i.Topic,
			&i.IsNsfw,
			&i.SlowmodeDelay,
			&i.UserLimit,
			&i.Bitrate,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncDeletedFriends = `-- name: SyncDeletedFriends :many
SELECT id FROM friends WHERE 1 = 0
`

// Get deleted friendships (track separately in audit or use soft delete)
// For now, returning empty - implement soft delete if needed
func (q *Queries) SyncDeletedFriends(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, syncDeletedFriends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncFriends = `-- name: SyncFriends :many
SELECT
    f.id,
    f.user_id,
    f.friend_id,
    f.status,
    f.alias_name,
    f.is_favorite,
    f.created_at,
    f.updated_at,
    u.id as friend_user_id,
    u.username as friend_username,
    u.email as friend_email,
    u.full_name as friend_full_name,
    u.profile_pic as friend_profile_pic,
    u.bio as friend_bio,
    u.color_code as friend_color_code,
    u.background_color as friend_background_color,
    u.background_pic as friend_background_pic,
    u.status as friend_status,
    u.custom_status as friend_custom_status,
    u.is_bot as friend_is_bot,
    u.is_verified as friend_is_verified,
    u.created_at as friend_created_at,
    u.updated_at as friend_updated_at
FROM friends f
    LEFT JOIN users u ON f.friend_id = u.id
WHERE
    f.user_id = $1
    AND f.updated_at > $2
ORDER BY f.updated_at DESC
LIMIT $3
OFFSET
    $4
`

type SyncFriendsParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Limit     int32            `json:"limit"`
	Offset    int32            `json:"offset"`
}

type SyncFriendsRow struct {
	ID                    int32            `json:"id"`
	UserID                int32            `json:"user_id"`
	FriendID              int32            `json:"friend_id"`
	Status                string           `json:"status"`
	AliasName             pgtype.Text      `json:"alias_name"`
	IsFavorite            pgtype.Bool      `json:"is_favorite"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	UpdatedAt             pgtype.Timestamp `json:"updated_at"`
	FriendUserID          pgtype.Int4      `json:"friend_user_id"`
	FriendUsername        pgtype.Text      `json:"friend_username"`
	FriendEmail           pgtype.Text      `json:"friend_email"`
	FriendFullName        pgtype.Text      `json:"friend_full_name"`
	FriendProfilePic      pgtype.Text      `json:"friend_profile_pic"`
	FriendBio             pgtype.Text      `json:"friend_bio"`
	FriendColorCode       pgtype.Text      `json:"friend_color_code"`
	FriendBackgroundColor pgtype.Text      `json:"friend_background_color"`
	FriendBackgroundPic   pgtype.Text      `json:"friend_background_pic"`
	FriendStatus          pgtype.Text      `json:"friend_status"`
	FriendCustomStatus    pgtype.Text      `json:"friend_custom_status"`
	FriendIsBot           pgtype.Bool      `json:"friend_is_bot"`
	FriendIsVerified      pgtype.Bool      `json:"friend_is_verified"`
	FriendCreatedAt       pgtype.Timestamp `json:"friend_created_at"`
	FriendUpdatedAt       pgtype.Timestamp `json:"friend_updated_at"`
}

// Get all friends updated after last_updated_at timestamp
func (q *Queries) SyncFriends(ctx context.Context, arg SyncFriendsParams) ([]SyncFriendsRow, error) {
	rows, err := q.db.Query(ctx, syncFriends,
		arg.UserID,
		arg.UpdatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncFriendsRow
	for rows.Next() {
		var i SyncFriendsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FriendID,
			&i.Status,
			&i.AliasName,
			&i.IsFavorite,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FriendUserID,
			&i.FriendUsername,
			&i.FriendEmail,
			&i.FriendFullName,
			&i.FriendProfilePic,
			&i.FriendBio,
			&i.FriendColorCode,
			&i.FriendBackgroundColor,
			&i.FriendBackgroundPic,
			&i.FriendStatus,
			&i.FriendCustomStatus,
			&i.FriendIsBot,
			&i.FriendIsVerified,
			&i.FriendCreatedAt,
			&i.FriendUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncInvites = `-- name: SyncInvites :many
SELECT i.id, i.code, i.server_id, i.channel_id, i.inviter_id, i.max_uses, i.uses, i.max_age, i.temporary, i.created_at, i.expires_at
FROM invites i
    INNER JOIN server_members sm ON i.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND i.created_at > $2
ORDER BY i.created_at DESC
`

type SyncInvitesParams struct {
	UserID    int32            `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type SyncInvitesRow struct {
	ID        int32            `json:"id"`
	Code      string           `json:"code"`
	ServerID  int32            `json:"server_id"`
	ChannelID pgtype.Int4      `json:"channel_id"`
	InviterID int32            `json:"inviter_id"`
	MaxUses   pgtype.Int4      `json:"max_uses"`
	Uses      pgtype.Int4      `json:"uses"`
	MaxAge    pgtype.Int4      `json:"max_age"`
	Temporary pgtype.Bool      `json:"temporary"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	ExpiresAt pgtype.Timestamp `json:"expires_at"`
}

// Get server invites updated after last_updated_at
func (q *Queries) SyncInvites(ctx context.Context, arg SyncInvitesParams) ([]SyncInvitesRow, error) {
	rows, err := q.db.Query(ctx, syncInvites, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncInvitesRow
	for rows.Next() {
		var i SyncInvitesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.ServerID,
			&i.ChannelID,
			&i.InviterID,
			&i.MaxUses,
			&i.Uses,
			&i.MaxAge,
			&i.Temporary,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncMessageAttachments = `-- name: SyncMessageAttachments :many
SELECT ma.id, ma.message_id, ma.file_name, ma.file_url, ma.file_size, ma.file_type, ma.width, ma.height, ma.created_at
FROM message_attachments ma
WHERE
    ma.message_id = ANY ($1::int[])
ORDER BY ma.message_id, ma.id
`

type SyncMessageAttachmentsRow struct {
	ID        int32            `json:"id"`
	MessageID int32            `json:"message_id"`
	FileName  string           `json:"file_name"`
	FileUrl   string           `json:"file_url"`
	FileSize  int64            `json:"file_size"`
	FileType  string           `json:"file_type"`
	Width     pgtype.Int4      `json:"width"`
	Height    pgtype.Int4      `json:"height"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

// Get message attachments for synced messages
func (q *Queries) SyncMessageAttachments(ctx context.Context, dollar_1 []int32) ([]SyncMessageAttachmentsRow, error) {
	rows, err := q.db.Query(ctx, syncMessageAttachments, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncMessageAttachmentsRow
	for rows.Next() {
		var i SyncMessageAttachmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.FileName,
			&i.FileUrl,
			&i.FileSize,
			&i.FileType,
			&i.Width,
			&i.Height,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncMessageReactions = `-- name: SyncMessageReactions :many
SELECT mr.id, mr.message_id, mr.user_id, mr.emoji, mr.created_at
FROM message_reactions mr
WHERE
    mr.message_id = ANY ($1::int[])
ORDER BY mr.message_id, mr.created_at
`

type SyncMessageReactionsRow struct {
	ID        int32            `json:"id"`
	MessageID int32            `json:"message_id"`
	UserID    int32            `json:"user_id"`
	Emoji     string           `json:"emoji"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

// Get message reactions for synced messages
func (q *Queries) SyncMessageReactions(ctx context.Context, dollar_1 []int32) ([]SyncMessageReactionsRow, error) {
	rows, err := q.db.Query(ctx, syncMessageReactions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncMessageReactionsRow
	for rows.Next() {
		var i SyncMessageReactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.UserID,
			&i.Emoji,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncMessages = `-- name: SyncMessages :many
SELECT
    m.id,
    m.channel_id,
    m.sender_id,
    m.content,
    m.message_type,
    m.reply_to_message_id,
    m.is_edited,
    m.is_pinned,
    m.mention_everyone,
    m.created_at,
    m.updated_at,
    m.edited_at,
    u.username as sender_username,
    u.profile_pic as sender_profile_pic
FROM messages m
    LEFT JOIN users u ON m.sender_id = u.id
WHERE
    m.channel_id = $1
    AND m.updated_at > $2
ORDER BY m.created_at DESC
LIMIT $3
OFFSET
    $4
`

type SyncMessagesParams struct {
	ChannelID pgtype.Int4      `json:"channel_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Limit     int32            `json:"limit"`
	Offset    int32            `json:"offset"`
}

type SyncMessagesRow struct {
	ID               int32            `json:"id"`
	ChannelID        pgtype.Int4      `json:"channel_id"`
	SenderID         int32            `json:"sender_id"`
	Content          string           `json:"content"`
	MessageType      pgtype.Text      `json:"message_type"`
	ReplyToMessageID pgtype.Int4      `json:"reply_to_message_id"`
	IsEdited         pgtype.Bool      `json:"is_edited"`
	IsPinned         pgtype.Bool      `json:"is_pinned"`
	MentionEveryone  pgtype.Bool      `json:"mention_everyone"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	EditedAt         pgtype.Timestamp `json:"edited_at"`
	SenderUsername   pgtype.Text      `json:"sender_username"`
	SenderProfilePic pgtype.Text      `json:"sender_profile_pic"`
}

// Get messages updated after last_updated_at
func (q *Queries) SyncMessages(ctx context.Context, arg SyncMessagesParams) ([]SyncMessagesRow, error) {
	rows, err := q.db.Query(ctx, syncMessages,
		arg.ChannelID,
		arg.UpdatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncMessagesRow
	for rows.Next() {
		var i SyncMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToMessageID,
			&i.IsEdited,
			&i.IsPinned,
			&i.MentionEveryone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EditedAt,
			&i.SenderUsername,
			&i.SenderProfilePic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncPendingFriendRequests = `-- name: SyncPendingFriendRequests :many
SELECT
    f.id,
    f.user_id,
    f.friend_id,
    f.status,
    f.alias_name,
    f.is_favorite,
    f.created_at,
    f.updated_at,
    u.id as requester_id,
    u.username as requester_username,
    u.profile_pic as requester_profile_pic,
    u.status as requester_status
FROM friends f
    LEFT JOIN users u ON f.user_id = u.id
WHERE
    f.friend_id = $1
    AND f.status = 'pending'
    AND f.updated_at > $2
ORDER BY f.created_at DESC
LIMIT $3
`

type SyncPendingFriendRequestsParams struct {
	FriendID  int32            `json:"friend_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Limit     int32            `json:"limit"`
}

type SyncPendingFriendRequestsRow struct {
	ID                  int32            `json:"id"`
	UserID              int32            `json:"user_id"`
	FriendID            int32            `json:"friend_id"`
	Status              string           `json:"status"`
	AliasName           pgtype.Text      `json:"alias_name"`
	IsFavorite          pgtype.Bool      `json:"is_favorite"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	RequesterID         pgtype.Int4      `json:"requester_id"`
	RequesterUsername   pgtype.Text      `json:"requester_username"`
	RequesterProfilePic pgtype.Text      `json:"requester_profile_pic"`
	RequesterStatus     pgtype.Text      `json:"requester_status"`
}

// Get pending friend requests updated after last_updated_at
func (q *Queries) SyncPendingFriendRequests(ctx context.Context, arg SyncPendingFriendRequestsParams) ([]SyncPendingFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, syncPendingFriendRequests, arg.FriendID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncPendingFriendRequestsRow
	for rows.Next() {
		var i SyncPendingFriendRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FriendID,
			&i.Status,
			&i.AliasName,
			&i.IsFavorite,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RequesterID,
			&i.RequesterUsername,
			&i.RequesterProfilePic,
			&i.RequesterStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncPermissions = `-- name: SyncPermissions :many
SELECT cp.id, cp.channel_id, cp.role_id, cp.user_id, cp.allow_permissions, cp.deny_permissions, cp.created_at
FROM
    channel_permissions cp
    INNER JOIN channels c ON cp.channel_id = c.id
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND cp.created_at > $2
ORDER BY cp.created_at DESC
`

type SyncPermissionsParams struct {
	UserID    int32            `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type SyncPermissionsRow struct {
	ID               int32            `json:"id"`
	ChannelID        int32            `json:"channel_id"`
	RoleID           pgtype.Int4      `json:"role_id"`
	UserID           pgtype.Int4      `json:"user_id"`
	AllowPermissions pgtype.Int8      `json:"allow_permissions"`
	DenyPermissions  pgtype.Int8      `json:"deny_permissions"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

// Get channel permissions updated after last_updated_at
func (q *Queries) SyncPermissions(ctx context.Context, arg SyncPermissionsParams) ([]SyncPermissionsRow, error) {
	rows, err := q.db.Query(ctx, syncPermissions, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncPermissionsRow
	for rows.Next() {
		var i SyncPermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.RoleID,
			&i.UserID,
			&i.AllowPermissions,
			&i.DenyPermissions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncServerMembers = `-- name: SyncServerMembers :many
SELECT sm.id, sm.server_id, sm.user_id, sm.nickname, sm.joined_at, u.username, u.profile_pic, u.status
FROM server_members sm
    LEFT JOIN users u ON sm.user_id = u.id
WHERE
    sm.server_id = $1
    AND sm.joined_at > $2
ORDER BY sm.joined_at DESC
`

type SyncServerMembersParams struct {
	ServerID int32            `json:"server_id"`
	JoinedAt pgtype.Timestamp `json:"joined_at"`
}

type SyncServerMembersRow struct {
	ID         int32            `json:"id"`
	ServerID   int32            `json:"server_id"`
	UserID     int32            `json:"user_id"`
	Nickname   pgtype.Text      `json:"nickname"`
	JoinedAt   pgtype.Timestamp `json:"joined_at"`
	Username   pgtype.Text      `json:"username"`
	ProfilePic pgtype.Text      `json:"profile_pic"`
	Status     pgtype.Text      `json:"status"`
}

// Get server members updated after last_updated_at
func (q *Queries) SyncServerMembers(ctx context.Context, arg SyncServerMembersParams) ([]SyncServerMembersRow, error) {
	rows, err := q.db.Query(ctx, syncServerMembers, arg.ServerID, arg.JoinedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncServerMembersRow
	for rows.Next() {
		var i SyncServerMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.UserID,
			&i.Nickname,
			&i.JoinedAt,
			&i.Username,
			&i.ProfilePic,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncServers = `-- name: SyncServers :many
SELECT s.id, s.name, s.icon, s.banner, s.description, s.owner_id, s.region, s.member_count, s.is_verified, s.vanity_url, s.created_at, s.updated_at
FROM servers s
    INNER JOIN server_members sm ON s.id = sm.server_id
WHERE
    sm.user_id = $1
    AND s.updated_at > $2
ORDER BY s.updated_at DESC
`

type SyncServersParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type SyncServersRow struct {
	ID          int32            `json:"id"`
	Name        string           `json:"name"`
	Icon        pgtype.Text      `json:"icon"`
	Banner      pgtype.Text      `json:"banner"`
	Description pgtype.Text      `json:"description"`
	OwnerID     int32            `json:"owner_id"`
	Region      pgtype.Text      `json:"region"`
	MemberCount pgtype.Int4      `json:"member_count"`
	IsVerified  pgtype.Bool      `json:"is_verified"`
	VanityUrl   pgtype.Text      `json:"vanity_url"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

// Get servers user is member of, updated after last_updated_at
func (q *Queries) SyncServers(ctx context.Context, arg SyncServersParams) ([]SyncServersRow, error) {
	rows, err := q.db.Query(ctx, syncServers, arg.UserID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncServersRow
	for rows.Next() {
		var i SyncServersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Icon,
			&i.Banner,
			&i.Description,
			&i.OwnerID,
			&i.Region,
			&i.MemberCount,
			&i.IsVerified,
			&i.VanityUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncTextChannels = `-- name: SyncTextChannels :many
SELECT c.id, c.server_id, c.category_id, c.name, c.type, c.position, c.topic, c.is_nsfw, c.slowmode_delay, c.is_private, c.created_at, c.updated_at
FROM channels c
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND c.type IN (
        'text',
        'announcement',
        'forum'
    )
    AND c.updated_at > $2
ORDER BY c.server_id, c.position
`

type SyncTextChannelsParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type SyncTextChannelsRow struct {
	ID            int32            `json:"id"`
	ServerID      int32            `json:"server_id"`
	CategoryID    pgtype.Int4      `json:"category_id"`
	Name          string           `json:"name"`
	Type          string           `json:"type"`
	Position      pgtype.Int4      `json:"position"`
	Topic         pgtype.Text      `json:"topic"`
	IsNsfw        pgtype.Bool      `json:"is_nsfw"`
	SlowmodeDelay pgtype.Int4      `json:"slowmode_delay"`
	IsPrivate     pgtype.Bool      `json:"is_private"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

// Get text channels from user's servers, updated after last_updated_at
func (q *Queries) SyncTextChannels(ctx context.Context, arg SyncTextChannelsParams) ([]SyncTextChannelsRow, error) {
	rows, err := q.db.Query(ctx, syncTextChannels, arg.UserID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncTextChannelsRow
	for rows.Next() {
		var i SyncTextChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.CategoryID,
			&i.Name,
			&i.Type,
			&i.Position,
			&i.Topic,
			&i.IsNsfw,
			&i.SlowmodeDelay,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncUserMessages = `-- name: SyncUserMessages :many
SELECT m.id, m.channel_id, m.sender_id, m.content, m.message_type, m.reply_to_message_id, m.is_edited, m.is_pinned, m.mention_everyone, m.created_at, m.updated_at, m.edited_at
FROM
    messages m
    INNER JOIN channels c ON m.channel_id = c.id
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND m.updated_at > $2
ORDER BY m.created_at DESC
LIMIT $3
OFFSET
    $4
`

type SyncUserMessagesParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Limit     int32            `json:"limit"`
	Offset    int32            `json:"offset"`
}

type SyncUserMessagesRow struct {
	ID               int32            `json:"id"`
	ChannelID        pgtype.Int4      `json:"channel_id"`
	SenderID         int32            `json:"sender_id"`
	Content          string           `json:"content"`
	MessageType      pgtype.Text      `json:"message_type"`
	ReplyToMessageID pgtype.Int4      `json:"reply_to_message_id"`
	IsEdited         pgtype.Bool      `json:"is_edited"`
	IsPinned         pgtype.Bool      `json:"is_pinned"`
	MentionEveryone  pgtype.Bool      `json:"mention_everyone"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	EditedAt         pgtype.Timestamp `json:"edited_at"`
}

// Get all messages for channels user has access to
func (q *Queries) SyncUserMessages(ctx context.Context, arg SyncUserMessagesParams) ([]SyncUserMessagesRow, error) {
	rows, err := q.db.Query(ctx, syncUserMessages,
		arg.UserID,
		arg.UpdatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncUserMessagesRow
	for rows.Next() {
		var i SyncUserMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToMessageID,
			&i.IsEdited,
			&i.IsPinned,
			&i.MentionEveryone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncUserProfile = `-- name: SyncUserProfile :one
SELECT
    id,
    username,
    email,
    full_name,
    profile_pic,
    bio,
    color_code,
    background_color,
    background_pic,
    status,
    custom_status,
    is_bot,
    is_verified,
    is_2fa_enabled,
    created_at,
    updated_at
FROM users
WHERE
    id = $1
    AND updated_at > $2
`

type SyncUserProfileParams struct {
	ID        int32            `json:"id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type SyncUserProfileRow struct {
	ID              int32            `json:"id"`
	Username        string           `json:"username"`
	Email           string           `json:"email"`
	FullName        pgtype.Text      `json:"full_name"`
	ProfilePic      pgtype.Text      `json:"profile_pic"`
	Bio             pgtype.Text      `json:"bio"`
	ColorCode       pgtype.Text      `json:"color_code"`
	BackgroundColor pgtype.Text      `json:"background_color"`
	BackgroundPic   pgtype.Text      `json:"background_pic"`
	Status          string           `json:"status"`
	CustomStatus    pgtype.Text      `json:"custom_status"`
	IsBot           pgtype.Bool      `json:"is_bot"`
	IsVerified      pgtype.Bool      `json:"is_verified"`
	Is2faEnabled    pgtype.Bool      `json:"is_2fa_enabled"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

// Get user profile if updated after last_updated_at
func (q *Queries) SyncUserProfile(ctx context.Context, arg SyncUserProfileParams) (SyncUserProfileRow, error) {
	row := q.db.QueryRow(ctx, syncUserProfile, arg.ID, arg.UpdatedAt)
	var i SyncUserProfileRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.ProfilePic,
		&i.Bio,
		&i.ColorCode,
		&i.BackgroundColor,
		&i.BackgroundPic,
		&i.Status,
		&i.CustomStatus,
		&i.IsBot,
		&i.IsVerified,
		&i.Is2faEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const syncVoiceChannels = `-- name: SyncVoiceChannels :many
SELECT c.id, c.server_id, c.category_id, c.name, c.type, c.position, c.topic, c.user_limit, c.bitrate, c.is_private, c.created_at, c.updated_at
FROM channels c
    INNER JOIN server_members sm ON c.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND c.type IN ('voice', 'stage')
    AND c.updated_at > $2
ORDER BY c.server_id, c.position
`

type SyncVoiceChannelsParams struct {
	UserID    int32            `json:"user_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type SyncVoiceChannelsRow struct {
	ID         int32            `json:"id"`
	ServerID   int32            `json:"server_id"`
	CategoryID pgtype.Int4      `json:"category_id"`
	Name       string           `json:"name"`
	Type       string           `json:"type"`
	Position   pgtype.Int4      `json:"position"`
	Topic      pgtype.Text      `json:"topic"`
	UserLimit  pgtype.Int4      `json:"user_limit"`
	Bitrate    pgtype.Int4      `json:"bitrate"`
	IsPrivate  pgtype.Bool      `json:"is_private"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
}

// Get voice channels from user's servers, updated after last_updated_at
func (q *Queries) SyncVoiceChannels(ctx context.Context, arg SyncVoiceChannelsParams) ([]SyncVoiceChannelsRow, error) {
	rows, err := q.db.Query(ctx, syncVoiceChannels, arg.UserID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncVoiceChannelsRow
	for rows.Next() {
		var i SyncVoiceChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.CategoryID,
			&i.Name,
			&i.Type,
			&i.Position,
			&i.Topic,
			&i.UserLimit,
			&i.Bitrate,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncVoiceStates = `-- name: SyncVoiceStates :many
SELECT vs.id, vs.user_id, vs.channel_id, vs.server_id, vs.session_id, vs.is_muted, vs.is_deafened, vs.self_mute, vs.self_deaf, vs.self_video, vs.self_stream, vs.suppress, vs.joined_at
FROM
    voice_states vs
    INNER JOIN server_members sm ON vs.server_id = sm.server_id
WHERE
    sm.user_id = $1
    AND vs.joined_at > $2
ORDER BY vs.joined_at DESC
`

type SyncVoiceStatesParams struct {
	UserID   int32            `json:"user_id"`
	JoinedAt pgtype.Timestamp `json:"joined_at"`
}

type SyncVoiceStatesRow struct {
	ID         int32            `json:"id"`
	UserID     int32            `json:"user_id"`
	ChannelID  int32            `json:"channel_id"`
	ServerID   pgtype.Int4      `json:"server_id"`
	SessionID  string           `json:"session_id"`
	IsMuted    pgtype.Bool      `json:"is_muted"`
	IsDeafened pgtype.Bool      `json:"is_deafened"`
	SelfMute   pgtype.Bool      `json:"self_mute"`
	SelfDeaf   pgtype.Bool      `json:"self_deaf"`
	SelfVideo  pgtype.Bool      `json:"self_video"`
	SelfStream pgtype.Bool      `json:"self_stream"`
	Suppress   pgtype.Bool      `json:"suppress"`
	JoinedAt   pgtype.Timestamp `json:"joined_at"`
}

// Get active voice states for user's servers
func (q *Queries) SyncVoiceStates(ctx context.Context, arg SyncVoiceStatesParams) ([]SyncVoiceStatesRow, error) {
	rows, err := q.db.Query(ctx, syncVoiceStates, arg.UserID, arg.JoinedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncVoiceStatesRow
	for rows.Next() {
		var i SyncVoiceStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ChannelID,
			&i.ServerID,
			&i.SessionID,
			&i.IsMuted,
			&i.IsDeafened,
			&i.SelfMute,
			&i.SelfDeaf,
			&i.SelfVideo,
			&i.SelfStream,
			&i.Suppress,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
