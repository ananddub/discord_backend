// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: member_roles.sql

package repo

import (
	"context"
)

const assignRoleToMember = `-- name: AssignRoleToMember :one
INSERT INTO
    member_roles (member_id, role_id)
VALUES ($1, $2)
RETURNING
    id, member_id, role_id, assigned_at, updated_at
`

type AssignRoleToMemberParams struct {
	MemberID int32 `json:"member_id"`
	RoleID   int32 `json:"role_id"`
}

func (q *Queries) AssignRoleToMember(ctx context.Context, arg AssignRoleToMemberParams) (MemberRole, error) {
	row := q.db.QueryRow(ctx, assignRoleToMember, arg.MemberID, arg.RoleID)
	var i MemberRole
	err := row.Scan(
		&i.ID,
		&i.MemberID,
		&i.RoleID,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMemberRoles = `-- name: GetMemberRoles :many
SELECT r.id, r.server_id, r.name, r.color, r.hoist, r.position, r.permissions, r.mentionable, r.icon, r.description, r.is_default, r.is_deleted, r.created_at, r.updated_at
FROM roles r
    INNER JOIN member_roles mr ON r.id = mr.role_id
WHERE
    mr.member_id = $1
ORDER BY r.position DESC
`

func (q *Queries) GetMemberRoles(ctx context.Context, memberID int32) ([]Role, error) {
	rows, err := q.db.Query(ctx, getMemberRoles, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.Name,
			&i.Color,
			&i.Hoist,
			&i.Position,
			&i.Permissions,
			&i.Mentionable,
			&i.Icon,
			&i.Description,
			&i.IsDefault,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleMembers = `-- name: GetRoleMembers :many
SELECT sm.id, sm.server_id, sm.user_id, sm.nickname, sm.joined_at, sm.is_muted, sm.is_deafened, sm.updated_at
FROM
    server_members sm
    INNER JOIN member_roles mr ON sm.id = mr.member_id
WHERE
    mr.role_id = $1
`

func (q *Queries) GetRoleMembers(ctx context.Context, roleID int32) ([]ServerMember, error) {
	rows, err := q.db.Query(ctx, getRoleMembers, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServerMember
	for rows.Next() {
		var i ServerMember
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.UserID,
			&i.Nickname,
			&i.JoinedAt,
			&i.IsMuted,
			&i.IsDeafened,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllMemberRoles = `-- name: RemoveAllMemberRoles :one
DELETE FROM member_roles WHERE member_id = $1 RETURNING id, member_id, role_id, assigned_at, updated_at
`

func (q *Queries) RemoveAllMemberRoles(ctx context.Context, memberID int32) (MemberRole, error) {
	row := q.db.QueryRow(ctx, removeAllMemberRoles, memberID)
	var i MemberRole
	err := row.Scan(
		&i.ID,
		&i.MemberID,
		&i.RoleID,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeRoleFromMember = `-- name: RemoveRoleFromMember :one
DELETE FROM member_roles
WHERE
    member_id = $1
    AND role_id = $2
RETURNING
    id, member_id, role_id, assigned_at, updated_at
`

type RemoveRoleFromMemberParams struct {
	MemberID int32 `json:"member_id"`
	RoleID   int32 `json:"role_id"`
}

func (q *Queries) RemoveRoleFromMember(ctx context.Context, arg RemoveRoleFromMemberParams) (MemberRole, error) {
	row := q.db.QueryRow(ctx, removeRoleFromMember, arg.MemberID, arg.RoleID)
	var i MemberRole
	err := row.Scan(
		&i.ID,
		&i.MemberID,
		&i.RoleID,
		&i.AssignedAt,
		&i.UpdatedAt,
	)
	return i, err
}
