// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_presence.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearExpiredCustomStatuses = `-- name: ClearExpiredCustomStatuses :exec
UPDATE user_presence
SET 
    custom_status = NULL,
    custom_status_emoji = NULL,
    custom_status_expires_at = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE custom_status_expires_at IS NOT NULL 
  AND custom_status_expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) ClearExpiredCustomStatuses(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearExpiredCustomStatuses)
	return err
}

const getMultipleUserPresences = `-- name: GetMultipleUserPresences :many
SELECT id, user_id, status, custom_status, custom_status_emoji, custom_status_expires_at, activity, last_seen, updated_at FROM user_presence
WHERE user_id = ANY($1::int[])
`

func (q *Queries) GetMultipleUserPresences(ctx context.Context, dollar_1 []int32) ([]UserPresence, error) {
	rows, err := q.db.Query(ctx, getMultipleUserPresences, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserPresence
	for rows.Next() {
		var i UserPresence
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.CustomStatus,
			&i.CustomStatusEmoji,
			&i.CustomStatusExpiresAt,
			&i.Activity,
			&i.LastSeen,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPresence = `-- name: GetUserPresence :one
SELECT id, user_id, status, custom_status, custom_status_emoji, custom_status_expires_at, activity, last_seen, updated_at FROM user_presence
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserPresence(ctx context.Context, userID int32) (UserPresence, error) {
	row := q.db.QueryRow(ctx, getUserPresence, userID)
	var i UserPresence
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CustomStatus,
		&i.CustomStatusEmoji,
		&i.CustomStatusExpiresAt,
		&i.Activity,
		&i.LastSeen,
		&i.UpdatedAt,
	)
	return i, err
}

const setCustomStatus = `-- name: SetCustomStatus :exec
UPDATE user_presence
SET 
    custom_status = $2,
    custom_status_emoji = $3,
    custom_status_expires_at = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

type SetCustomStatusParams struct {
	UserID                int32            `json:"user_id"`
	CustomStatus          pgtype.Text      `json:"custom_status"`
	CustomStatusEmoji     pgtype.Text      `json:"custom_status_emoji"`
	CustomStatusExpiresAt pgtype.Timestamp `json:"custom_status_expires_at"`
}

func (q *Queries) SetCustomStatus(ctx context.Context, arg SetCustomStatusParams) error {
	_, err := q.db.Exec(ctx, setCustomStatus,
		arg.UserID,
		arg.CustomStatus,
		arg.CustomStatusEmoji,
		arg.CustomStatusExpiresAt,
	)
	return err
}

const updatePresenceStatus = `-- name: UpdatePresenceStatus :exec
UPDATE user_presence
SET status = $2, last_seen = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

type UpdatePresenceStatusParams struct {
	UserID int32       `json:"user_id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdatePresenceStatus(ctx context.Context, arg UpdatePresenceStatusParams) error {
	_, err := q.db.Exec(ctx, updatePresenceStatus, arg.UserID, arg.Status)
	return err
}

const upsertUserPresence = `-- name: UpsertUserPresence :one
INSERT INTO user_presence (
    user_id, status, custom_status, custom_status_emoji, activity, last_seen
) VALUES (
    $1, $2, $3, $4, $5, CURRENT_TIMESTAMP
)
ON CONFLICT (user_id) 
DO UPDATE SET
    status = EXCLUDED.status,
    custom_status = EXCLUDED.custom_status,
    custom_status_emoji = EXCLUDED.custom_status_emoji,
    activity = EXCLUDED.activity,
    last_seen = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, status, custom_status, custom_status_emoji, custom_status_expires_at, activity, last_seen, updated_at
`

type UpsertUserPresenceParams struct {
	UserID            int32       `json:"user_id"`
	Status            pgtype.Text `json:"status"`
	CustomStatus      pgtype.Text `json:"custom_status"`
	CustomStatusEmoji pgtype.Text `json:"custom_status_emoji"`
	Activity          pgtype.Text `json:"activity"`
}

func (q *Queries) UpsertUserPresence(ctx context.Context, arg UpsertUserPresenceParams) (UserPresence, error) {
	row := q.db.QueryRow(ctx, upsertUserPresence,
		arg.UserID,
		arg.Status,
		arg.CustomStatus,
		arg.CustomStatusEmoji,
		arg.Activity,
	)
	var i UserPresence
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CustomStatus,
		&i.CustomStatusEmoji,
		&i.CustomStatusExpiresAt,
		&i.Activity,
		&i.LastSeen,
		&i.UpdatedAt,
	)
	return i, err
}
